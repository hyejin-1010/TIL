# 알고리즘

## 1) 검색 알고리즘

### 선형 검색
	* 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는 지를 검사

```
For i from 0 to n-1
	If i'th element is 50
		Return true
Return fasle
```

### 이진 검색
	* 배열이 정렬되어 있는 경우, 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교하여 그보다 작은 인덱스 또는 큰 인덱스로 이동을 반복한다.

```
If no items
	Return false
If middle item is 50
	Return true
Else if 50 < middle item
	Search left half
Else if 50 > middle item
	Search right half
```

-

## 2) 알고리즘 표기법
### Big O 표기법
	* 실행 시간의 상한
	* O는 ‘on the order of’의 약자로, ‘~만큼의 정도로 커지는 것’이라고 볼 수 있다.
	* O(n/2)도 결국 n이 커지면 1/2은 큰 의미가 없어지므로, O(n)이라고 볼 수 있다.

> - O(n^2)  
> - O(n log n)  
> - O(n) : 선형 검색  
> - O(log n) : 이진 검색  
> - O(1)  

### Big Ω
	* 알고리즘 실행 시간의 하한

> Ω(n^2)  
> Ω(n log n)  
> Ω(n) : 배열 안에 존재하는 값의 개수 세기  
> Ω(log n)  
> Ω(1) : 선형 검색, 이진 검색  

## 3) 선형 검색
	* 원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 검색하는 알고리즘
	* 정확하지만 아주 효율적이지 못한 방법이다. 리스트의 길이가 n이라고 했을 때, 최악의 경우 리스트의 모든 원소를 확인해야 하기 때문에 n번만큼 실행된다.
	* 평균적으로 선형 검색이 최악의 상횡에서 종료되는 것에 가깝다고 가정할 수 있다.
	* 자료가 정렬되어 있지 않거나, 그 어떤 정보도 없어 하나씩 찾아야 하는 경우에 유용

> 정렬은 시간이 오래 걸리고 공간을 더 차지하나, 여러 번 리스트를 검색해야 하거나 매우 큰 리스트를 검색해야하는 경우 시간을 단축시킬 수 있다.  

## 4) 버블 정렬
	* 정렬 알고리즘 중 하나
	* 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법
	* 이는 단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중한다. 간단하지만, 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있다.

```
Repeat n-1 times
	For i from n-2
		If i'th and i+1'th elements out of order
			Swap them
```

	* 실생 시간의 상한은 O(n^2) 이다.
	* 정렬 여부와 관계없이 루프를 돌며 비교를 해야하기 때문에, 실행시간의 하한도 Ω(n^2) 이다.