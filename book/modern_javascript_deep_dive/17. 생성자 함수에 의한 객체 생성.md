## 17. 생성자 함수에 의한 객체 생성

### Object 생성자 함수
- new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환
- 빈 객체를 생성한 이후, 프로퍼티 또는 메서드를 추가하여 객체를 완성할 수 있다.
- 생성자 함수(constructor)란 new 연산자와 하몎 호출하여 객체(인스턴스)를 생성하는 함수를 의미
- 객체를 생성하는 방법은 객체 리터럴을 사용하는 것이 더 간편
- 특별한 이유가 없다면, 그다지 유용하지 않다.

### 생성자 함수
- 형식이 정해저 있는 것이 아닌, 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.
- 일반적으로 첫 문자를 대문자로 기술하는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있게끔 노력한다.


1. 객체 리터럴에 의한 객체 생성 방식의 문제점
	- 객체 리터럴에 의한 객체 생성 방식은 직관적이 간편
	- 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 비효율적
2. 생성자 함수에 의한 객체 생성 방식의 장점
	- 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여, 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.
3. 생성자 함수의 인스턴스 생성 과정
	1. 인스턴스 생성과 this 바인딩
	2. 인스턴스 초기화
	3. 인스턴스 반환
4. 내부 메서드 [[Call]]과 [[Construct]]
	- 일반 함수로서 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고, new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 [[Construct]]가 호출된다.
	- 내부 메서드 [[Call]]을 갖는 함수 객체를 callable
	- 내부 메서드 [[Construct]]를 갖는 함수 객체를 constructor, 갖지 않은 함수 객체를 non-contructor라고 부른다.
	- 함수 객체는 반드신 callable이어야 한다.
5. constructor와 non-contructor의 구분
	- contructor: 함수 선언문, 함수 표현식, 클래스
	- non-contructor: 메서드(ES6 메서드 축약 표현), 화살표 함수
	- 함수를 프로퍼티 값으로 사용하면 일반적으로 메서드로 통칭하지만, ECMAScript 사양에서 메서드란 ES6의 메서드 축약 표현만을 의미한다.
6. new 연산자
	- new 연산자와 함께 함수를 호출하면, 해당 함수는 생성자 함수로 동작한다.
	- [[Construct]]가 호출된다.
	- new 연산자와 함께 호출하는 함수는 non-contructor가 아닌 constructor이어야 한다.
7. new.target
	- ES6에서 지원
	- IE는 지원하지 않는다.
	- new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가르키지만, new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined이다.
	- new.tartget을 사용할 수 없는 상황이라면 스코프 세이프 생성자 패턴을 사용할 수 있다. ```this instanceof Circle```

> this는 자기 참조 변수로서, this의 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.<br/>
> 일반 함수로서 호출: 전역 객체<br/>
> 메서드로서 호출: 메서드를 호출한 객체<br/>
> 생성자 함수로서 호출: 생성자 함수가 (미래에)생성할 인스턴스

