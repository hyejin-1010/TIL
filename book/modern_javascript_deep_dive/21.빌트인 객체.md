## 21.빌트인 객체

### 자바스크립트 객체의 분류
- 표준 빌트인 객체(standart built-in objects/native objects/global objects)
	- EXMAScript 사양에 정의된 객체
	- 애플리케이션 전역의 공통 기능
	- 실행 환경과 관계없이 언제나 사용 가능
	- 전역 객체의 프로퍼티로서 제공
	- 별도의 선언없이 전역 변수처럼 언제나 참조 가능
- 호스트 객체 (host objects)
	- ECMAScript 사양에 정의되어 있지는 않으나, 자바스크립트 실행환경에서 추가로 제공하는 객체
	- 브라우저 환경에서는 클라이언트 사이드 Web API를, Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공
- 사용자 정의 객체 (user-defined objects)
	- 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체

### 표준 빌트인 객체
- 자바스크립트는 40여 개의 표준 빌트인 객체를 제공
- Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체이다.
- 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적 메서드를 제공하고, 아닌 표준 빌트인 객체는 정적 메서드만 제공한다.
- 생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체이다.

### 원시값과 래퍼 객체
- 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 래퍼 객체(wrapper object, 자바스크립트가 생성한 암묵적으로 생성한 연관된 객체)를 생성하여 프로퍼티를 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.
- 원시값은 래퍼객체의 내부 슬롯([[StringData]] .. ) 에 저장되어 있다가, 작업이 종료되면 되돌린다.
- 래퍼 객체는 가비지 컬렉션의 대상이 된다.
- 이에 new 연산자와 함께 빌트인 생성자 함수를 사용하여 인스턴스를 생성할 필요가 없으며, 권장하지도 않는다.
- ES6에서 새롭게 도입된 원시값인 심벌도 래퍼 객체를 생성하나, 일반 원시값과 달리 Symbol 함수를 통해 생성해야 하므로 다른 원시값과는 차이가 있다.
- null, undefined는 래퍼 객체를 생성하지 않는다. 객체처럼 사용하고자 한다면 에러가 발생한다.

### 전역 객체
- 어떤 객체보다도 먼저 생성되는 특수한 객체
- 어떤 객체에도 속하지 않은 최상위 객체
- ES11에는 globalThis, 전역 객체를 가리키던 다양한 식별자를 통일한 식별자가 도입되었다.
- 표준 빌트인 객체와 호스트 객체, var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.
- 최상위 객체라는 것은 프로토타입 상속 관계상에서 최상위 객체라는 의미는 아니다. 전역 객체는 어떤 객체의 프로퍼티도 아니다.
- 개발자가 의도적으로 생성할 수 없다.
- 참조할 때 window(또는 global)를 생략할 수 잇다.
- let/const로 선언한 키워드는 전역 객체의 프로퍼티가 아니다. 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재한다.
- 모든 자바스크립트 코드는 하나의 전역 객체를 공유한다. 코드를 분리해도 하나의 전역 객체를 공유함은 변함이 없다.

#### 빌트인 전역 프로퍼티
1. Infinity
	- 무한대를 나타내는 숫자값 Infinity
2. NaN
	- 숫자가 아님을 나타내는 숫자값 NaN
	- Number.NaN 프로퍼티와 같다.
3. undefined
	- 원시 타입 undefined 값

#### 빌트인 전역 함수
1. eval
	- 표현식: 런타임에 평가하여 값 생성
	- 문: 런타임에 실행
	- 여러 개의 문: 모든 문 실행
	- 기존의 스코프를 런타임에 동적으로 수정
	- strict mode에서는 기존의 스코프를 수정하지 않고 자체적인 스코프 생성
	- let, const 키워드를 사용한 변수 선언문은 암묵적으로 strict mode 적용
	- 보안 취약, 최적화가 수행되지 않아 처리 속도가 드림
	- eval 함수의 사용은 금지해야 한다.
2. isFinite
	- 정상적인 유한수인지 검사
	- 인수가 무한수 또는 NaN으로 평가되는 값인 경우 false 반환
3. isNaN
	- 전달받은 인수가 NaN인지
	- 숫자가 아닌 경우 숫자로 타입을 변환한 후 검사 수행
4. parseFloat
	- 전달받은 문자열 인수를 부동 소수점 숫자(= 실수)로 해석하여 반환
5. parseInt
	- 전달받은 문자열 인수를 정수로 해석하여 반환
	- 문자열이 아니면 문자열로 변환한 다음, 정수로 해석하여 반환
	- 두 번째 인수로는 진법을 나타내는 기수(2~36)을 전달할 수 있다. 해당 기수의 숫자로 해석하여 반환하나, 반환값은 언제나 10진수이다. 생략하면 10진수로 해석.
	- 10진수 숫자를 해당 기수의 문자열로 반환하고 싶은 경우 Number.prototype.toString 메서드를 사용하면 된다.
	- '0x','0X'로 시작하는 16진수 리터럴인 경우 16진수로 해석하여 10진수 정수로 반환
	- 2진수 리터럴과 8진수 리터럴은 제대로 해석하지 못한다.
	- ES5 이전까지는 비로 사용을 금지하고는 있었으나 '0'으로 시작하는 숫자를 8진수로 해석했었다. ES6부터는 '0'으로 시작하는 숫자를 10진수로 해석한다.
	- 첫 번째 인수로 전달받은 문자열의 첫 번째 무나작 해당 지수의 숫자로 변환될 수 없다면 NaN을 반환한다.
	- 두 번째 인수부터 해당 진수를 나타내는 숫자가 아닌 문자를 마주치게 될 경우애는 이 문자와 계속되는 문자들은 전부 무시되며, 해석된 정수값만 반환한다.
	- 첫 번째 인수로 전달한 문자열에 공백이 있는 경우, 첫 번째 문자열만 해석하여 반환. 앞뒤 공백은 무시된다.
6. encodeURI / decodeURI
	- encodeURI: 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.
	- decodeURI: 인코딩된 URI를 인수로 전달받아 이스케이프 처리 이전으로 디코딩

> 이스케이프 처리: 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것.

7. encodeURIComponent / decodeURIComponent
	- encodeURIComponent : URI 구성 요소를 인수로 전달받아 인코딩
		- 인수로 전달된 문자열을 URI의 구성요소인 쿼리 스트링의 일부로 간주
		- 쿼리 스트링 구분자로 사용되는 -,?,&까지 인코딩한다.
		- encodeURI함수는 완전한 URI전체라고 간주하기 때문에 쿼리 스크링 구분자로 사용되는 =, ?, &은 인코딩하지 않는다.
	- decodeURIComponent : 매개변수로 전달된 URI 구성요소를 디코딩

#### 암묵적 전역
- 변수 선언 없디 전역 겍체 프로퍼티로 추가
- 따라서 암묵적 전역은 변수가 아니다. => 변수 호이스팅이 발생하지 않는다.
- 변수가 아닌 단지  **프로퍼티**이다.
- 따라서 암묵적 전역은 delete 연산자로 삭제할 수 있다. (전역 변수는 프로퍼티이지만 delete 연산자로 삭제할 수 없다.)