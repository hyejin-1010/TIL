# 1-1. 요구사항 확인
## 1. 소프트웨어 생명 주기
### 소프트웨어 생명 주기 (소프트웨어 수명 주기, Software Life Cycle)
* 소프트웨어 개발 방법론의 바탕이 되는 것.
* 소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 과정을 각 단계 별로 나눈 것.
* 소프트웨어 개발 단계와 각 단계별 주요 활동, 활동의 결과에 대한 산출물로 표현한다.

### 소프트웨어 생명 주기 모형
* 소프트웨어 프로세스 모형 또는 소프트웨어 공학 패러다임이라고도 한다.
* 개발자는 문제의 유형이나 개발 방법 등에 따라 특정 모형을 선택하여 사용할 수 있고, 개별적인 모형을 사용할 수 있다.
* 일반적으로 사용되는 것으로는 폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일 모형 등이 있다.

<br />

### 폭포수 모형 (Waterfall Model)
* 소프트웨어 개발도 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고, 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론이다.
* 소프트웨어 공학에서 가장 오래되고 가장  폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형으로, 고전적 생명 주기 모형이라고도 한다.
* 모형을 적용한 경험과 성공 사례가 많다.
* 제품의 일부가 될 매뉴얼을 작성해야 한다.
* 각 단계가 끝난 후에는 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 한다.
* 두 개 이상의 과정이 병행하여 수행되지 않는다.

> 타당성 검토 → 계획 → 요구 분석 → 설계 → 구현(코딩) → 시험(검사) → 유지 보수

<br />

### 프로토타입 모형(Prototype Mode, 원형 모형)
* 요구 사항을 정확하게 파악하기 위해 실제 개발될 소프트웨어에 대한 견본(시제)품(Prototype)을 만들어 최종 결과물을 예측하는 모형이다.
* 시제품은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발한다.
* 시스템의 일부 혹은 시스템의 모형을 만드는 과정으로서 요구된 소프트웨어를 구현하는데, 이는 추후 구현 단계에서 사용될 골격 코드가 된다.
* 소프트웨어 개발이 완료된 시점에서 오류가 발견되는 폭포수 모형의 단점을 보안하기 위한 모형이다.

> 요구 수집 → 빠른 설계 → 프로토타입 구축 → 고객 평가 → 프로토타입 조정 → 구현 → 처음으로

<br />

### 나선형 모형(Spiral Model, 점진적 모형)
* 보헴(Boehm)이 제안한 것이다.
* 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형.
* 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 것으로, 점진적 모형이라고 한다.
* 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 한다.
* 점진적으로 개발 과정이 반복되어, 누락되거나 추가된 요구사항을 첨가할 수 있고, 정밀하며, 유지 보수 과정이 필요 없다.

> 계획 수립 → 위험 분서 → 개발 및 검증 → 고객 평가 → 처음으로

<br />

### 애자일 모형 (Agile Model)
* 고객의 요구사항 변화에 유옇나헥 대응할 수 있도록 일정한 주기를 반복하면서 개발 과정을 진행한다.
* 고객과의 소통에 초점을 맞춘 방법론을 통칭한다.
* 기업 활동 전반에 걸쳐 사용된다.
* 스프린트(Sprint) / 인터레이션(Iteration)이라고 불리는 짧은 개발 주기를 반복하며, 반복되는 주기마다 만들어지는 결과물에 대한 고객의 평가와 요구를 적극 수용한다.
* 각 개발 주기에는 고객이 요구사항에 우선순위를 부여하여 개발 작업을 진행한다.
* 소규모 프로젝트, 고도로 숙달된 개발자, 급변하는 요구 사항에 적합하다.
* Ex) 스크럼(Scrum), XP(eXtream Programming), 칸반(Kanban), Lean, 크리스탈(Crystal), ASD(Adaptive Software Development), 기능 중심 개발(FDD; Feature Driven Development) , DSDM(Dynamic System Development), DAD(Disciplined Agile Delivery) 등 …

**에자일 4가지 핵심 가치**
1. 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다.
2. 방대한 문서보다는 실행되는 SW에 더 가치를 둔다.
3. 계약 협상보다는 고객과 협업에 더 가치를 둔다.
4. 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다.

<br />

### 소프트웨어 공학 (SE; Software Engineering)
* 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문
* 여러 가지 방법론과 도구, 관리 기법들을 통해 소프트웨어 품질과 생산성을 향상시킬 목적으로 한다.

**소프트웨어의 기본 원칙**
* 현대적인 프로그래밍 기술을 계속적으로 적용해야 한다.
* 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야 한다.
* 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 한다.

----

## 2. 스크럼(Scrum) 기법
* 팀원 스스로가 팀을 구성(self-organizing)해야 하며, 개발 작업에 관한 모든 것을 스스로가 해결(cross-functional)할 수 있어야 한다.

### 제품 책임자(PO, Product Owner)
* 이해관계자들 중 제품에 대한 이해도가 높고, 의사 결정한 사람.
* 의견을 종합하여 요구사항이 담긴 백로그(Backlog)를 작성 및 백로그에 대한 우선순위 지정
* 테스트를 수행하면서 주기적으로 우선순위 갱신

<br />

### 스크럼 마스터 (SM, Scrum Master)
* 객관적인 시각에서 조언을 해주는 가이드 역할
* 일일 스크럼 회의 주관: 진행상황 점검 및 발생된 장애 요소를 공론화하여 처리.

<br />

### 개발팀 (DT, Development Team)
* 제품 개발을 위해 참여하는 모든 사람.
* 보통 최대 인원은 7~8명이 적당.


<br />

### 스크럼 개발 프로세스

1. 제품 백로그(Product Backlog)
    * 제품 개발에 필요한 모든 요구사항(User Story)을 우선순위에 따라 나열한 목록, 지속적으로 업데이트 된다.
    * 기반으로 전체 일정 계획인 릴리즈 계획을 수립
2. 스프린트 계획 회의 (Sprint Planning Meeting)
   * 이번 스크립트에서 수행할 작업을 대상으로 단기 일정을 수립하는 것.
   * 태스크(Task) 작업 단위로 분할한 후, 개발자별로 수행할 작업목로인 스프린트 백로그(Sprint Backlog)를 작성.
3. 스프린트 (Sprint)
    * 실제 개발을 진행하는 과정, 보통 2 ~ 4주 정도의 기간 내에서 진행.
    * 개발자가 원하는 태스크를 직접 선별하여 담당할 수 있도록 하는 것이 좋다.
    * 태스크는 보통 할 일(To Do), 진행 중(In Progress), 완료(Done) 상태를 갖는다.
4. 일일 스크럼 회의 (Daily Scrum Meeting)
    * 매일 약 15분 정도의 짧은 시간동안 진행 상황을 검토.
    * 남은 작업 시간은 소멸 차트(Burn-down Chart)에 표시
    * 스크럼 마스터는 발생한 장애 요소를 해결할 수 있도록 도와준다.
5. 스프린트 검토 회의 (Sprint Review)
   * 사용자가 포함된 참석자 앞에서 테스팅 수행
   * 스프린트의 한 주당 한 시간 내에서 진행
   * 제품 책임자는 개선할 사항에 대한 피드백을 정리해, 다음 스프린트에 반영할 수 있도록 제품 백로그를 업데이트한다.
6. 스프린트 회고 (Sprint Retrospective)
   * 규칙을 잘 준수했는지, 개선할 점을 없는 지 등을 확인하고 기록.
   * 해당 스프린트가 끝난 시점 혹은 일정 주기로 수행.


----

## 3. XP(eXtream Programming)
* 고객의 참여와 개발 과정의 반복을 극대화하여, 개발 생산성을 향상시키는 방법
* 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 한다.
* 릴리즈의 기간을 짧게 반복해, 고객의 요구사항 반영에 대한 가시성을 높인다.
* 비교적 소규모 인원의 개발 프로젝트에 효과적

* **5가지 핵심 가치**: 의사소통(Communication), 단순성(Simplicity), 용기(Courage), 존중(Respect), 피드백(Feedback)

### XP 개발 프로세스
1. 사용자 스토리 (User Story)
   * 요구사항을 간단한 시나리오로 표현한 것.
   * 기능 단위로 구성하며, 필요한 경우 간단한 테스트 사항(Test Case)도 기재한다.
2. 릴리즈 계획 수립 (Release Planning)
    * 부분/전체 개발 완료 시점에 대한 일정 수립
3. 스파이크 (Spike)
    * 요구사항에 대한 신뢰성을 높이고, 기술 문제에 대한 위험을 감소시키기 위해 별도로 만드는 간단한 프로그램
    * 처리할 문제 외의 다른 조건은 모두 무시하고 작성
4. 이터레이션 (Iteration)
    * 하나의 릴리즈를 더 세부화한 단위.
    * 일반적으로 1~3주 정도의 기간으로 진행.
    * 이 기간 중 새로운 스토리가 작성될 수 있으며, 진행 중인 이터레이션/다음 이터레이션에 포함될 수 있다.
5. 승인 검사 (Acceptance Test, 인수 테스트)
    * 사용자 스토리 작성 시 함께 기재한 테스트 사항에 대하 고객이 직접 수행.
    * 발견한 오류는 다음 이터레이션에 포함된다.
    * 이후, 새로운 요구사항 작성 및 요구사항의 상대적 우선순위가 변경될 수 있다.
    * 완료되면 다음 이터레이션을 진행한다.
6. 소규모 릴리즈 (Small Release)
    * 릴리즈를 소규모로 하게 될 경우 고객의 반응을 기능별로 확인할 수 있어, 고객의 요구사항에 조금 더 유연하게 대응할 수 있다.
    * 진행된 이터레이션이 모두 완료되면, 고객에 의한 최종 테스트 수행 후, 최종 결과물을 고객에 전달한다.
    * 최종 완제품이 아닌 경우, 다음 릴리즈 일정에 맞게 개발을 계속 진행한다.

### 주요 실천 방법 (Practice)
1. Pair Programming (짝 프로그래밍)
2. Collective Ownership (공동 코드 소유)
3. Test-Driven Development (테스트 주도 개발)
4. Whole Team (전체 팀)
5. Continuous Integration (계속적인 통합)
6. Design Improvement (디자인 개선) 또는 Refactoring (리팩토링)
7. Small Release (소규모 릴리즈)

----

## 4. 현행 시스템 파악

**1. 시스템 구성 파악**
* 조직의 주요 업무를 담당하는 기간 업무와 이를 지원하는 지원 업무로 구분하여 기술.
* 조직 내 모든 정보 시스템의 현황을 파악할 수 있도록 각 업무에 속하는 단위 업무 정보시스템들의 명칭, 주요 기능들을 명시.

**2. 시스템 기능 파악**
* 단위 업무 시스템이 현재 제공하는 기능들을 주요 기능과 하부 기능, 세부 기능으로 구분하여 계층형으로 표시.


**3. 시스템 인터페이스 파악**
* 단위 업무 시스템 간에 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등을 명시
* 데이터를 어떤 형식으로 주고 받는지, 통신 규약은 무엇을 사용하는 지, 연계 유형은 무엇인지 등을 반드시 고려해야 한다.

**4. 아키텍쳐 구성 파악**
* 기간 업무 수행에 어떠한 기술 요소들이 사용되는 지 최상위 수준에서 계층별로 표현한 아키텍처 구성도로 작성한다.
* 단위 업무 시스템별로 다른 경우, 가장 핵심이 되는 기간 업무 처리 시스템을 기준으로 표현.

**5. 소프트웨어 구성 파악**
* 단위 업무 시스템별로 업무 처리를 위해 설치되어 있는 소프트웨어들의 제품명, 용도, 라이선스 적용 방식, 라이선스의 수 등을 명시
* 상용 소프트웨어의 경우 라이선스 적용 방식의 기준과 보유한 라이선스의 파악이 중요.

**6. 하드웨어 구성 파악**
* 단위 업무 시스템들이 운용되는 서버의 주요 사양과 수량, 그리고 이중화의 적용 여부를 명시.
* 서버의 이중화는 기간 업무의 서비스 기간, 장애 대응 정책에 따라 필요 여부가 결정됨.

**7. 네트워크 구성 파악**
* 업무 시스템들의 네트워크 구성을 파악할 수 있도록, 서버의 위치, 서버 간의 네트워크 연결 방식을 네트워크 구성도로 작성한다.
* 네트워크 구성도를 통해 서버들의 물리적인 위치 관계를 파악할 수 있고, 보안 취약성을 분석하여 적절한 대응 가능.
* 네트워크에 장애가 발생한 경우, 발생 원인을 찾아 복구하기 위한 용도로 활용.

